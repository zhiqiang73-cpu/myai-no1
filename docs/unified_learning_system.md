# 统一支撑阻力位学习系统 v4

## 核心思想

入场和出场都依赖支撑阻力位，因此使用**统一的学习系统**来优化6个特征权重。

## 学习流程

```
开仓 → 使用最佳支撑位(做多)/阻力位(做空)
  ↓
持仓 → 监控对面的阻力位/支撑位
  ↓
平仓 → 到达阻力位/支撑位时减仓
  ↓
记录 → 入场价位是否有效？出场价位是否有效？
  ↓
学习 → 统计分析6个特征的预测能力
  ↓
优化 → 微调特征权重（30笔交易后）
```

## 有效性判断

### 入场价位有效性
- **有效**：止损没被触发（价格确实在支撑位反弹/阻力位回落）
- **无效**：触发止损（价格突破了该价位）

### 出场价位有效性
- **有效**：价格到达该价位后确实反转（止盈触发、移动止损触发）
- **无效**：价格突破该价位继续运行（错过更多利润）

## 6个特征权重

| 特征 | 初始权重 | 说明 |
|------|----------|------|
| volume_density | 20% | 成交量密集度 |
| touch_bounce_count | 20% | 触及反弹次数 |
| failed_breakout_count | 20% | 假突破次数 |
| bounce_magnitude | 15% | 反弹幅度 |
| multi_tf_confirm | 15% | 多周期确认 |
| duration_days | 10% | 有效持续天数 |

## 权重调整算法

```python
# 每个特征的有用性 = 有效交易中的平均值 - 无效交易中的平均值
# 入场和出场分别计算，然后取平均

for feature in features:
    entry_diff = entry_effective_avg - entry_ineffective_avg
    exit_diff = exit_effective_avg - exit_ineffective_avg
    combined_diff = (entry_diff + exit_diff) / 2
    
    # 差值越大，特征越有用
    usefulness = 0.5 + combined_diff * 2
    new_weight = usefulness / total_usefulness

# 平滑更新（学习率0.3）
weight = old_weight * 0.7 + new_weight * 0.3
```

## 为什么不会冲突？

入场和出场验证的是**同一个问题**：这个价位的6个特征值，能否准确预测价格行为？

- 入场验证：支撑位是否真的支撑住了？
- 出场验证：阻力位是否真的阻挡住了？

两者都是验证特征的**预测能力**，所以可以统一学习。

## 前端显示

```
📊 学习: 15/30笔 (50%)
⏳ 积累中...
入场: 67%  出场: 50%  总: 60%
```

## 预期效果

随着交易次数增加：
1. 有效的特征权重会增加
2. 无效的特征权重会降低
3. 最佳支撑/阻力位的准确率会提高
4. 入场和出场的有效率都会提升
